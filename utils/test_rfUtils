import time
import numpy as np
import math
import SoapySDR
# import utils.modes as modes
from utils.config import *
# import utils.motorUtils as motorUtils

# --- GLOBAL VARIABLES ---
# baseline_avgs = {}   # Baseline averages
rssi = -100  # Default low RSSI
sdr = None   # Global SDR device holder
rxStream = None # Global Stream holder

# --- HACKRF SETUP (Run this ONCE at startup) ---
def setupSDR(freq_mhz=channels[0]):
    global sdr, rxStream
    try:
        # 1. Connect to device
        devices = SoapySDR.Device.enumerate()
        if len(devices) == 0:
            print("ERROR: No HackRF found!")
            return False
        
        sdr = SoapySDR.Device(devices[0])
        
        # 2. Configure settings
        # Lowered sample rate to 2MHz (enough for RSSI, saves CPU/USB load)
        sdr.setSampleRate(SoapySDR.SOAPY_SDR_RX, 0, 2e6) 
        sdr.setFrequency(SoapySDR.SOAPY_SDR_RX, 0, freq_mhz * 1e6)
        sdr.setGain(SoapySDR.SOAPY_SDR_RX, 0, 30) # Slightly higher gain for detection
        
        # 3. Setup the stream (Allocates memory, but does not start it yet)
        rxStream = sdr.setupStream(SoapySDR.SOAPY_SDR_RX, SoapySDR.SOAPY_SDR_CF32)
        print(f"HackRF Initialized on {freq_mhz} MHz")
        return True
    except Exception as e:
        print(f"Failed to setup SDR: {e}")
        return False

def closeSDR():
    global sdr, rxStream
    if rxStream is not None:
        sdr.closeStream(rxStream)
    sdr = None

# --- FAST READING FUNCTION ---
def readRssi():
    global rssi, sdr, rxStream
    
    # Safety check
    if sdr is None:
        print("SDR not initialized, trying to reconnect...")
        if not setupSDR():
            return -100

    # 1. Start the flow of data
    sdr.activateStream(rxStream) 
    
    # Array to store accumulated power for averaging
    power_readings = []
    
    # Create a buffer (numpy array) for the samples
    buff = np.empty(1024, np.complex64) 

    try:
        # We read a few buffers to get a stable average
        for _ in range(10): 
            sr = sdr.readStream(rxStream, [buff], len(buff))
            
            # Error checking on the read
            if sr.ret <= 0:
                continue # Skip bad reads
            
            # Slice the valid data
            valid_samples = buff[:sr.ret]
            
            # Calculate Power (I^2 + Q^2)
            # We use absolute squared to be faster: (real^2 + imag^2)
            power_val = np.mean(np.abs(valid_samples)**2)
            
            if power_val > 0:
                power_readings.append(power_val)
                
    except Exception as e:
        print(f"Read Error: {e}")

    finally:
        # 2. IMPORTANT: Stop the flow immediately to prevent buffer overflow/crash
        sdr.deactivateStream(rxStream)

    # Calculate final RSSI in dB
    if len(power_readings) > 0:
        avg_power = np.mean(power_readings)
        # 10*log10 because it is power. +1e-12 avoids log(0) error
        rssi_dbfs = 10.0 * math.log10(avg_power + 1e-12)
        rssi = rssi_dbfs # Update global
    else:
        # Keep previous rssi or set to noise floor if read failed
        pass 

    return rssi

# --- EXISTING UTILS (Unchanged logic, just calling the new readRssi) ---

# def getRssi():
#     global rssi
#     return rssi

# def scanBaseline():
#     global baseline_avgs
#     coords = motorUtils.getCoordString()
    
#     # This now calls the FAST internal function, not subprocess
#     current_rssi = readRssi() 
    
#     if coords not in baseline_avgs:
#         baseline_avgs[coords] = 0
#     # Rolling average calculation could be improved, but keeping your logic:
#     baseline_avgs[coords] += current_rssi / setup_sweep_count 

# def getRssiSubBaseline():
#     global baseline_avgs
#     coords = motorUtils.getCoordString()
#     rssi_value = readRssi()
    
#     # Safety: If coordinate doesn't exist in baseline, assume 0 or min value
#     baseline = baseline_avgs.get(coords, -100)
    
#     comp_value = rssi_value - baseline
#     return comp_value

# def rfCompBaseline(): 
#     comp_value = getRssiSubBaseline()
#     if comp_value > rssi_threshold:
#         print(f"Drone detected! Level: {comp_value:.2f} dB above baseline") 
#         modes.searchMode()

# Auto-initialize on import if you prefer, 
# or call utils.rfUtils.setupSDR() from your main.py
# setupSDR()

try:
    setupSDR()

    for _ in range(100):
        rssi_value = readRssi()
        print(f"Current RSSI: {rssi_value:.2f} dBFS")
        time.sleep(0.1)
    closeSDR()
    print("SDR closed after test.")
except KeyboardInterrupt:
    print("Terminated by user.")
finally:
    closeSDR()
    print("SDR closed.")